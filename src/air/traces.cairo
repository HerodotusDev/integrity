use cairo_verifier::channel::channel::ChannelTrait;
use cairo_verifier::table_commitment::table_commitment::{
    TableUnsentCommitment, TableCommitment, TableDecommitment, TableCommitmentWitness, table_commit,
    table_decommit,
};
use cairo_verifier::air::{public_input::PublicInput, traces_config::TracesConfig};
use cairo_verifier::channel::channel::Channel;

// A protocol component (see stark.cairo for details about protocol components) for the traces
// of the CPU AIR.
// This component is commonly right before the FRI component.
// In this case:
//   n_queries = n_fri_queries * 2^first_fri_step.
//   decommitment.original.n_queries = n_original_columns * n_queries.
//   decommitment.interaction.n_queries = n_interaction_columns * n_queries.

// Commitment values for the Traces component. Used to generate a commitment by "reading" these
// values from the channel.
#[derive(Drop, Copy)]
struct TracesUnsentCommitment {
    original: TableUnsentCommitment,
    interaction: TableUnsentCommitment,
}

// Commitment for the Traces component.
#[derive(Drop)]
struct TracesCommitment {
    public_input: PublicInput,
    // Commitment to the first trace.
    original: TableCommitment,
    // The interaction elements that were sent to the prover after the first trace commitment (e.g.
    // memory interaction).
    interaction_elements: Array<felt252>,
    // Commitment to the second (interaction) trace.
    interaction: TableCommitment,
}

// Responses for queries to the AIR commitment.
// The queries are usually generated by the next component down the line (e.g. FRI).
#[derive(Drop)]
struct TracesDecommitment {
    // Responses for queries to the original trace.
    original: TableDecommitment,
    // Responses for queries to the interaction trace.
    interaction: TableDecommitment,
}

// A witness for a decommitment of the AIR traces over queries.
#[derive(Drop)]
struct TracesWitness {
    original: TableCommitmentWitness,
    interaction: TableCommitmentWitness,
}

// Reads the traces commitment from the channel.
// Returns the commitment, along with GlobalValue required to evaluate the constraint polynomial.
fn traces_commit(
    ref channel: Channel,
    n_interaction_elements: felt252,
    public_input: PublicInput,
    unsent_commitment: TracesUnsentCommitment,
    config: TracesConfig
) -> TracesCommitment {
    // Read original commitment.
    let original_commitment = table_commit(unsent_commitment.original, config.original);
    // Generate interaction elements for the first interaction.
    let interaction_elements = channel.random_felts_to_prover(n_interaction_elements);
    // Read interaction commitment.
    let interaction_commitment = table_commit(unsent_commitment.interaction, config.interaction);

    TracesCommitment {
        public_input: public_input,
        original: original_commitment,
        interaction_elements: interaction_elements,
        interaction: interaction_commitment,
    }
}

// Verifies a decommitment for the traces at the query indices.
// decommitment - holds the commited values of the leaves at the query_indices.
fn traces_decommit(
    queries: Span<felt252>,
    commitment: TracesCommitment,
    decommitment: TracesDecommitment,
    witness: TracesWitness,
) {
    table_decommit(commitment.original, queries, decommitment.original, witness.original);
    table_decommit(commitment.interaction, queries, decommitment.interaction, witness.interaction)
}
